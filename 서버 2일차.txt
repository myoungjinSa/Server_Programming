*게임 서버 종류:

1. 로비 서버 (for MOG)
-실제 게임을 하기 전에 같이 플레이 할 상대를 찾는곳
- 채팅서버의 확장
- 실제 게임은 P2P로 이루어 짐 -> 단점: 맵핵을 못 막고, 해킹의 위험에 취약
	* 현재는 P2P 가 아니라 Client/Server 로 실제 게임을 구현하는 추세
-길드, 클랜, 아이템 구매 지원 

2. MMOG 서버
-MUD의 서버가 효시 -> Multi User Dungeon,
-게임 컨텐츠가 다 서버에 들어 있음.
- 서버의 부하가 크다.

* 게임 서버의 설계 목표(안전성, 성능)
- 쾌적한 게임 환경
  1. 랙 없는 서버, 안전정인 서버
-동접
 1. 게임성 : 경제 시스템, 커뮤니티
 2. 서비스 비용 절약
-핫 스팟
 1. 게임 컨텐츠 제약 완화 : 이벤트 , 공성전, 혈맹전

*성능 향상을 위한 해결책
 -효율적인 프로그래밍
 - 부하 분산 ( 여러 대의 컴퓨터) -> 계속 늘리면 나중엔 효과가 없다.

*pc속도 높이는 법 : 2가지 ;
 1. 클럭 속도 높이는것. -> 오버클럭은 서버 가 불안정해져 해결책이 아니다.
 2. 코어 개수 높이는것.

*176개의 코어까지만 늘릴수 있다- > 인텔에서 그 이상이 들어가는 cpu를 만들지 않는다

* 부하 분산
 - 서버 분리 (샤딩, Sharding) -> ex> 메이플 
  => 특징 : - 월드 복사 & 분리 -> 기술적으로 어려운게 없다. 그냥 컴퓨터 한대 더 사서 실행파일 복사하면 됨
	  - 다른 월드로 이동 불가 
	   - DB가 분리되어 있음.
               - 통합하는 추세  EX> 공동 경매장, 공동 인던 입장, 서버간 결투, 공동 ZONE
	  
 - 기능별 분산
 => 특징 : - 사용자 분리 없이 확장
	 - 부하가 크기 때문에 여러 종류의 서버의 조합으로 구성(기능별 분리) 
	   1. Main Sever => 실제 사용자가 접속해서 게임을 하는 서버
 	   2. Login Server => 사용자를 확인한 후 메인 서버에 접속시켜 주는 서버
	   3. AI Server(NPC Server) => NPC들의 AI를 담당하는 서버
 	   4. DB 서버 
	->저거 보다 더 잘게 쪼개는거는 잘 생각해봐야함, cpu부하는 줄어들지만 소켓 통신간에 오버헤드가 커짐

=>한계 : -메인 서버에 부하가 집중된다.
	- 더 이상 기능적으로 나눌 수 없다. (통신 부담 증가) 
  
=> 메인 서버의 부하 감소를 위한 분할
	- 공간 분할  : Zone 서버 (접속을 맡느 Master Server 따로 있다.)
	 1. 전체 맵을 지역별로 나누어서 다른 서버가 관리.
	 2. Portal 방식과 seamless 의 두가지 방식이 있다.
	 3. 예) Portal: 1. wow의 대륙 분할 - 다른 서버로 넘어갈때 중간에 잠시 끊김,
	        	     2. 구현하기 쉬움 
		     3.  
	        Seamless:1. BigWorld - 다른 서버로 넘어갈때 스무스하게
		    	2. 구현 어려움.
			3. 경계선 근처에 서있는 물체를 2개 이상의 서버가 동시에 관찰할 수 있어야함.
		
		       => 정적 분할과 동적 분할
			1. 동적 분할 : 사람 더 많이 몰리는 곳으로 경계선 이동. 해당 서버에 부하 줄여줌


	 4. 이동 가능, 샤딩이랑은 달리 각 서버가 다른 컨텐츠를 관리, 이동할때 서버간에 플레이어 데이터 전송 과정 필요
	
	- 접속 분할:  Duplicate Server
	1.동일한 공간의 Clone을 만들어서 각각 다른 서버가 관리
	2. 예) Mu(수동),GuildWar(자동)
	3. 샤딩과는 다르다. (샤딩 과는 달리 DB를 공유하고 있음 )	  
	4.메인서버만 복사하면 되서 구현 쉽다. 
	5. 접속 분할은 여러개를 만들수 없다. (DB의 한계 때문) -> 보통은 샤딩과 같이 하기도 함.


*게임 서버 하드웨어
 - 하드 웨어 지식이 필요한 이유
	1. 서버에 걸리는 부하가 많기 때문에 하드웨어의 성능을 최대한 끌어내는 프로그래밍이 필요하다.
	2. 하드웨어의 성능을 최대한 끌어 내려면 하드웨어가 어떻게 성능에 영향을 미치는지 알아야함.

- 중요 하드웨어
	 1. cpu
	 2. Memory
	 3. Network
	-하드 디스크랑은 상관없어야함. -> 즉 프로그램 실행중에 하드 디스크를 엑세스하게 하는것은 잘못.

-CPU
	1.X86 계열이 대세이다. 
	2.종류 : Intel ,AMD , 
	          ARM (스마트폰 전용), -> 너무 느림
	          POWER PC(PS3) -> 너무 비쌈  
	3. AMD와 Intel 2가지 계열이 있다.
		- 서버용 cpu가 따로 존재함.
		- 예) Intel Xeon, AMD EPYC
		- xeon CPU -> 여러개 CPU 가능 - cache 동기화 지원 (Cache에서 Cache로 데이터 전송)

	4.64bit 와 multi core
	
	5.서버용 CPU 와 일반 Desktop용 cpu의 차이
		- 서버용 cpu는 multi Processor를 지원한다.
			1. cache 동기화 지원
		- 서버용 cpu는 서로간의 데이터 전송 전용 통로를 제공한다.
			1.AMD: HyperTransport(2001~)- 51GB/s
			2. intel : QPI()
		-메모리 채널 증가: 8개 까지	
		
	6. 서버용 CPU를 구매하려면 XEON CPU를 사야함.

* 64비트 이슈
	1. 64 비트를 사용한다.
	 -OS와 Compiler도 64비트 버전을 사용해야 한다.
	2. 기존의 32비트 cpu로는 최대 4GB의 메모리 밖에 쓸 수 없었기 때문에 서버 용량에 제한이 많았음
	3.64비트의 경우 16ExtraByte의 메모리가 가능하다.
	4. 프로그래밍 시 int type과 pointer type의 크기가 달라지는것을 주의해야함.
	5. 32bit로 하면 안됨.

*게임 서버 하드웨어 (CPU)
	1.Multi-Processor
		- SMP -> 모든 cpu는 모든 메모리에 동등하게 접근 가능.
		-빠른 네트워크 응답속도와 처리 속도 개선을 위해 Multi-Processor을 사용
	2. Multi-core
		-발열에 막힌 cpu의 성능 향상 제한을 극복하기 위한 궁여지책
		-기존의 4~8개의 cpu를 활용하던 프로그램 방식에서 8~64개의 core를 
		활용하도록 변경 필요. 앞으로도 계속 core개수가 늘어날 예정.
	3.Multi-Processor 와 multi-core의 차이점
		-SW적으로는 차이가 없음.
		-HW적으로는 메모리 접근시 성능 차이가 존재
			1.CPU의 개수 만큼 메모리 대역폭 증가.
			2,NUMA(Non Uniform Memory Access)문제

*cpu발전의 Trend
	-클럭 속도 증가
		1. 반도체 생산 공정 개선
		2. 한계에 부딪힘: 발열
	- Clock당 수행되는 명령어의 개수 증가
		1. 아키텍쳐의 개선
		2. Pipeline , SiperScalar,SuperPipeline,Out-of-Order
		3. 캐시 용량 증가
		4. 한계에 부딛침: 한계효용의 법칙
	-Core 개수 증가
		1. 현재의 방식, 프로그램 작성 방식이 바뀌어야 함.
		2. 발열로 인한 클럭속도 향상의 한계가 주 원인.
		3. 현재 32-Core 까지 (앞으로 계속 늘어날 예정)

*파이프라인의 발전
	-어떤 명령어를 수행하는데 몇 cycle 이 걸리는가? 라는 질문은 의미가 없음
	-파이프라인이 무효화 되지 않는 한 프로그램의 실행 속도는 메모리 Read 에 종속됨
		*명령어가 더 많아도 메모리 Read가 적으면 더 빠름
*SIMD 명령어의 발전
	-하나의 명령어로 여러개의 실수를 동시에 연산

*Pipeline 의 고도화에 따른 주의
	-파이프라인을 리셋 시키면 손해가 너무 크다
	-리셋의 원인 
		*시스템콜 -> 프로그래머 선에서 처리 가능
		*분기예측오류
		*인터럽트 -> 프로그래머 선에서 처리 불가능
	
*cache 
 1.프로그램 실행 속도에 가장 큰 영향을 미치는 요소
2. cache가 큰 cpu일 수록 속도가 더 빠르다

*tip
1.같이 쓰이게 되는 데이터는 묶어 놓는다.
2.루프안에서 사용하는 데이터는 캐쉬에 다 올라올수 있도록 한다.
3.int 대신에 half(short)나 char을 사용한다.


*Multi Processor Programming
 -잘하면 N배 성능 향상, 못하면 성능 하락
 - Lock을 줄여라
 	1.Lock으로 보호 받는 코드는 N배 성능향상에서 예죄
	2. Lock 자체 부하: 버스 locking
	3.Semaphore,Condition 변수는 시스템 콜 -> lock보다 느리다.
-Cache Thrashing 에 주의
	1.Cache 는 line 단위로 움직임


*메모리
	-서버가 요구하는 용량을 제공하면된다.
	-일반적인 Desktop용 메모리가 아니라 Error수정 기능이 있는 특수 메모리를 사용한다.
	-대역폭이 크지만 반응 속도는 느리다.
	
*메모리 값이 아주 가끔 바뀌는 경우가 있는데 -> 방사능에 영향을 받아서

*네트워크 
	-10M-> 100M->1G ->10G 까지 발전
	-서버간의 연결을 위해 한 서버에 여러개의 네트워크 카드를 꽂아서 사용


* 서버용 운영체제의 종류
 - UNIX 계열
  1.리눅스 , freeBSD, Solaris, OSx
  2. 가격이 저렴하다.
  3. 유지 보수가 어렵다.(잘 아는 사람이 필요)

 -Windows 계열
 1. Windows 2008,Windows 2012,Windows 2016 -> 이 서버 전용 운영체제는 서버에 필요없는 기능을 다 덜어냄,(안정성,보안 좋음)
-> 서버는 윈도우 10 사용 불가
 2. 비싸다
 3. 유지 보수 관리가 비교적 쉽다.(배우기 쉬움, 신경쓸 것이 적음)

(리눅스, 윈도우) 성능이 거기서 거기. 쓰기 나름


*프로그램 최적화

-첫번째 : 꼭 필요한 일만 하기
	1. 시스템 호출 최소화(new/delete 포함)
-두번째 : 좋은 알고리즘 사용하기 
-세번째 : 메모리 복사 줄이기 
	1.call by value 대신 call by Reference 
	2. Copy Constructor 사용 회피
-네번째 : HW 영향 고려
	1.캐시, 파이프라인
-다섯번째 : 멀티쓰레드 프로그래밍

-여섯번째 : 게임이 실행되서 FrameAdvance에서 파일I.O(시스템 호출)하면 안됨



 *성능 향상
-하드웨어가 프로그래밍 성능에 미치는 영향 실습
1. 시스템 CALL
2. Cache
3. Pipeline

*this_thread::yeild(); -> 다른 스레드에게 양보

*Pipeline Stall
- 분기 예측이 없어야함

우리들 컴퓨터는 파이프라인 20단계로 구성 -> 20배 빠를수 있음
게다가 슈퍼스칼라로 3 명령어를 한번에 패치 -> 3배 빠름
총 60배 빠를수 있음


*
 