실습 : passward : 다음주이다
MMO게임 (물량) -> 최적화 -> 동접 -> BroadCast

- c++로 AI구현은 시간도 많이 걸릴 뿐더러 어렵다.

-인공지능은 주로 스크립트로 구현
-하지만 스크립트는 성능이 느리기때문에 
길찾기 알고리즘같은거나 적 인식은 C로 구현


*적 인식
-플레이어의 생성,이동이 NPC를 깨워주는것.
-플레이어의 이동을 근처 NPC에만 broadcast -> 서버에 막대한 부하를 막을 수 있음
-NPC 리스폰시에도 검사 필요

-능동적 AI는 만들면 안된다.

*NPC 구현
-NPC 서버를 따로 구현
1.장점 : -안정성: NPC모듈이 죽어도 서버 정상 작동 -> 플레이어 데이터 손실을 막을 수 있음
           -.부하 분산: 메모리 &CPU

2.단점: -통신 OVERHEAD 
	1.공유 메모리 참조로 끝날일이 패킷통신으로 악화
	2. 서버 입장에서는 NPC도 플레이어와 비슷한 부하

- 몇년전만해도 NPC서버 분리하지 않고 메인서버에서 한다.
하지만 최근에는 또 생동감 있는 NPC들을 구현하려면 인던서버가 한다.


*길찾기
-이동
클라에서 이동을 하고 서버에게 이동했다고 알려준다. 
-> 서버에서 검사를 해야할게 플레이어 속도, 근처 장애물 등을 검사해서 
맞으면 다른 클라에게 이동된 클라이언트 위치를 보내줘야함. 

-> WASD이동시 길찾기 알고리즘 불필요
->마우스 클릭 이동은 길찾기 알고리즘이 필요 -> 하지만 클라에서 함

->NPC 길찾기는 서버에서 해야함.
-서버가 지형과 장애물을 알아야 한다.

*클라이언트는 플레이어가 서있는 주위만 메모리 로딩해서 지형 검사를 하면되지만
 서버는 모든 지형을 로딩해야함.

*지형 구현
-2D지형
1. 타일 방식
2. 2D 배열로 지형 표현 -> O(1)
3. 이동 가능 불가능 FLAG 이 CELL마다 존재 -> 메모리 절약하기 위해서
4. 서버 안에서의 모든 OBJECT 의 좌표는 정수
5. 자로 잰듯한 줄서기(만) 가능
6. 2D 이미지를 토대로 사람이 TILE을 작성 - 주로 레벨 디자이너

EX > 리니지1, 던파,바람의 나라, 스타 1,2, 디아블로1,2,3 , 리니지 2레볼루션 -> 몇몇은 클라는 3D지만 서버는 2D


-3D 지형
1. 확장 타일
 1> Tile 방식
 2> 3D배열로 지형 표현
     -> 배열 구현시 메모리 낭비가 심해서 Sparce Matrix 로 표현 하지만 O(n) 걸림
     -> 많은 부분이 단층지형이므로 2D타일을 사용하고 복층 구조로 된 일부 부분에 필요한 데이터만 다른 메모리 주소에 할당한다.
     -> 단점:충돌이 부자연스럽다. 경사를 졌거나 동그란 벽을 만들면 안됨, 벽이 각진 던전만 만들어야함
 
2. 3D 지형 폴리곤 방식
 1> 클라이언트의 visual Data 를 그대로 사용
    ->서버에서는 메시 충돌검사가 아닌 별도의 충돌체 검사만 한다. 
 2> 클라이언트와 비슷한 방법으로 이동 가능 검사
    -> 물리 엔진 필요
    -> 지형 표현 정밀도 증가

* 지형 구현의 issue
 - 충돌 정보 가공
	1. Path Node
	2. Path Mesh (Navigation Mesh)
	
 - 문의 구현
	1. 특수 지형 속성? 
	2. npc? 	->  
 - 이동 가능 지형
	1. 엘리베이터 , 배 , 이동 발판 

*길찾기

-Path node : 가장 가까운 노드를 찾고 그 노드로부터 해당 위치까지 최단거리를 구한다.

-Path Mesh : 지나갈수 있는 통로를 볼록 다각형의 모임으로 만들어 놓는다.  -> 요즘 많이 사용됨. 3d지형의 경우 굉장히 자연스러움



*기본 길 찾기 방식

-다음 step 의 위치 정하기
	1. 단위 시간에 갈 수 있는 직선상의 위치
	2. 다음 tile: 단위 시간이 가변적임 -> tile같은경우는 시간단위를 조절해서 속도를 표현 ex> 1초보다 0.8초 마다 보내는 패킷이 이동속도가 더 빠름
	3. 방향 전환점
-step이 필요한 이유
	1. 패킷 캐수 절약, 계산 시간 절약 => timer를 통한 이동

-매 step 마다 다시 길 찾기 필요 -> 비효율적이지 않음 
	1. 목표 이동(플레이어 위치 변화), 지형 변화(다른 npc의 길막기), 장애물 변화(엘리베이터 이동)

-npc 이동 : 사람이 봤을 때 어색하지 않을정도로 이동패킷을 보내야하는지. (0.5초 ~ 1초 )
	 꺾이는 곳의 좌표는 무조건 클라에게 알려줘야함. 
	

-길찾기 알고리즘 :
1, 타겟과 직선상의 위치하면 a*알고리즘 할 필요 없이 바로 직선 경로로 이동한다.

 

*길찾기 알고리즘의 종류

1. 가면서 찾기 => 검색을 하지 않고 대충 가는거 (지도를 모를때)
-지형 전체를 알 수 없는 경우
	1. 멍청한 npc
	2. 빠른 계산
	3. 마이크로 마우스 미로찾기 	
-간단한 장애물들만 있을 때 사용해야함.
-직선 찾아 돌기는 100퍼센트 길을 찾을 수 있음 ->그러나 효율적이지는 않음
- 시간 복잡도 : O(1)

2. 미리 찾기 => (지도를 알 때)
-Depth first Search는 못씀 -> 왜냐하면 목표를 찾을때까지 멀리 나갈 수 있기때문
	1.IDDF  -> 비효율적이고, 최단거리라고 보장할 수 없음
- Breadth-first Search 를 써야함
	1. bidirectional -> 모든 노드 사이에 거리가 동일할때 최단거리라고 보장됨. 2D타일 게임에서나 사용 가능
	2. 다익스트라 -> 무조건 최단거리를 찾음 
		단점: 시간 복잡도 : O(n제곱)

	3. A* => F(n) = G(n) + H(n) 
		-H(n) : 도착점까지의 근사 비용 -> 정확한 값은 아님
		-그래프가 교차하지 않기만 한다면 A*는 항상 최적의 결과를 뽑아낸다.







